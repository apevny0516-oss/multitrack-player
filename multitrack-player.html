<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multitrack Player</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.min.js"></script>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; padding: 1rem; }
    .track { background: white; padding: 1rem; margin-bottom: 0.5rem; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    button { cursor: pointer; border: 1px solid #ccc; border-radius: 4px; padding: 0.25rem 0.5rem; }
    button.active { background-color: #007bff; color: white; border-color: #007bff; }
    .progress-container { margin-top: 1rem; position: relative; }
    .time { font-size: 0.8rem; display: flex; justify-content: space-between; color: #555; }
    .loop-highlight { position: absolute; top: 50%; height: 6px; background: rgba(0,123,255,0.3); border-radius: 3px; transform: translateY(-50%); pointer-events: none; }
  </style>
</head>
<body>
  <h2>Multitrack Player</h2>
  <div>
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="stop">Stop</button>
    <button id="loop">Loop Start</button>
    <label>Pitch (Semitones) <input id="pitch" type="range" min="-12" max="12" step="1" value="0"></label>
    <label>Master Volume <input id="masterVol" type="range" min="0" max="1" step="0.01" value="1"></label>
  </div>

  <div id="progressContainer" class="progress-container"></div>
  <div id="tracks"></div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const stems = [];
    for (const [key, value] of params.entries()) {
      stems.push({ name: key, url: value });
    }

    const trackData = [];
    let playing = false;
    let startAt = 0, pausedAt = 0;
    let raf;

    let loopActive = false, loopStart = null, loopEnd = null;

    const loopButton = document.getElementById('loop');
    const progressContainer = document.getElementById('progressContainer');
    const progress = document.createElement('input');
    progress.type = 'range';
    progress.min = 0;
    progress.max = 1;
    progress.step = 0.001;
    progress.value = 0;
    progress.style.width = '100%';
    progress.style.display = 'block';
    progress.style.marginTop = '1rem';

    const loopHighlight = document.createElement('div');
    loopHighlight.className = 'loop-highlight';
    progressContainer.appendChild(loopHighlight);

    const timeRow = document.createElement('div');
    timeRow.className = 'time';
    const currentTimeEl = document.createElement('span');
    currentTimeEl.textContent = '0:00';
    const totalTimeEl = document.createElement('span');
    totalTimeEl.textContent = '0:00';
    timeRow.appendChild(currentTimeEl);
    timeRow.appendChild(totalTimeEl);
    progressContainer.appendChild(progress);
    progressContainer.appendChild(timeRow);

    const masterVol = document.getElementById('masterVol');
    const pitchSlider = document.getElementById('pitch');

    const pitchShift = new Tone.PitchShift(0).toDestination();
    const masterGain = new Tone.Volume(0).toDestination();

    masterVol.addEventListener('input', e => {
      masterGain.volume.value = Tone.gainToDb(Number(e.target.value));
    });

    pitchSlider.addEventListener('input', e => {
      pitchShift.pitch = Number(e.target.value);
    });

    async function loadStems() {
      for (const s of stems) {
        const player = new Tone.Player(s.url);
        if (s.name.toLowerCase() !== 'drums' && s.name.toLowerCase() !== 'metronome') {
          player.connect(pitchShift);
        } else {
          player.toDestination();
        }
        await player.load();
        trackData.push({ name: s.name, player: player, buffer: player.buffer, gain: 1, muted: false, solo: false });
      }
      renderTracks();
      updateDuration();
    }

    function renderTracks() {
      const container = document.getElementById('tracks');
      container.innerHTML = '';
      trackData.forEach((t) => {
        const div = document.createElement('div');
        div.className = 'track';
        div.innerHTML = `
          <strong>${t.name}</strong><br>
          <button data-action="solo">Solo</button>
          <button data-action="mute">Mute</button>
          <label>Vol <input data-action="gain" type="range" min="0" max="2" step="0.01" value="1"></label>
        `;
        div.querySelectorAll('button, input').forEach(el => {
          el.addEventListener('click', (e) => handleTrackControl(e, t));
          el.addEventListener('input', (e) => handleTrackControl(e, t));
        });
        container.appendChild(div);
      });
      updateButtonStates();
    }

    function handleTrackControl(e, track) {
      const act = e.target.dataset.action;
      if (act === 'gain') track.gain = Number(e.target.value);
      if (act === 'mute') track.muted = !track.muted;
      if (act === 'solo') track.solo = !track.solo;
      updateButtonStates();
    }

    function updateButtonStates() {
      document.querySelectorAll('.track').forEach((trackDiv, index) => {
        const track = trackData[index];
        const soloBtn = trackDiv.querySelector('button[data-action="solo"]');
        const muteBtn = trackDiv.querySelector('button[data-action="mute"]');
        soloBtn.classList.toggle('active', track.solo);
        muteBtn.classList.toggle('active', track.muted);
      });
    }

    function playAll(offset = 0) {
      Tone.Transport.stop();
      Tone.Transport.cancel();
      trackData.forEach(t => {
        if (t.player.buffer) {
          t.player.start(0, offset);
        }
      });
      playing = true;
      startAt = Tone.now() - offset;
      updateProgress();
    }

    function stopAll() {
      trackData.forEach(t => t.player.stop());
      playing = false;
      cancelAnimationFrame(raf);
    }

    function pauseAll() {
      stopAll();
      pausedAt = Tone.now() - startAt;
    }

    function updateDuration() {
      const total = trackData.reduce((m, t) => Math.max(m, t.buffer ? t.buffer.duration : 0), 0);
      totalTimeEl.textContent = formatTime(total);
    }

    function renderLoopHighlight() {
      const total = trackData.reduce((m, t) => Math.max(m, t.buffer ? t.buffer.duration : 0), 0);
      if (!total || !loopStart || !loopEnd) return;
      const startPct = loopStart / total * 100;
      const endPct = loopEnd / total * 100;
      loopHighlight.style.left = `${startPct}%`;
      loopHighlight.style.width = `${endPct - startPct}%`;
      loopHighlight.style.display = 'block';
    }

    function clearLoopHighlight() {
      loopHighlight.style.display = 'none';
    }

    function updateProgress() {
      if (!playing) return;
      const total = trackData.reduce((m, t) => Math.max(m, t.buffer ? t.buffer.duration : 0), 0);
      const elapsed = Tone.now() - startAt;
      const progressValue = Math.min(elapsed / total, 1);
      progress.value = progressValue;
      currentTimeEl.textContent = formatTime(elapsed);

      if (loopActive && loopStart !== null && loopEnd !== null && elapsed >= loopEnd) {
        playAll(loopStart);
        return;
      }
      if (progressValue < 1) raf = requestAnimationFrame(updateProgress);
    }

    function seekTo(pct) {
      const total = trackData.reduce((m, t) => Math.max(m, t.buffer ? t.buffer.duration : 0), 0);
      const sec = pct * total;
      pausedAt = sec;
      if (playing) playAll(sec);
      else currentTimeEl.textContent = formatTime(sec);
    }

    function formatTime(sec) {
      if (!sec || isNaN(sec)) return '0:00';
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    progress.addEventListener('input', (e) => {
      seekTo(Number(e.target.value));
    });

    loopButton.addEventListener('click', () => {
      const current = Tone.now() - startAt;
      if (!loopStart && !loopEnd) {
        loopStart = current;
        loopButton.textContent = 'Loop End';
      } else if (loopStart && !loopEnd) {
        loopEnd = current;
        loopActive = true;
        loopButton.textContent = 'Clear Loop';
        loopButton.classList.add('active');
        renderLoopHighlight();
      } else {
        loopActive = false;
        loopStart = null;
        loopEnd = null;
        loopButton.textContent = 'Loop Start';
        loopButton.classList.remove('active');
        clearLoopHighlight();
      }
    });

    document.getElementById('play').onclick = () => {
      if (!playing) playAll(pausedAt);
    };
    document.getElementById('pause').onclick = pauseAll;
    document.getElementById('stop').onclick = () => {
      pausedAt = 0;
      stopAll();
      progress.value = 0;
      currentTimeEl.textContent = '0:00';
    };

    loadStems();
  </script>
</body>
</html>
